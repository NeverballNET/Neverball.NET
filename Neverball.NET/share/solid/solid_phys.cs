//  The original source code has been ported to .NET with deep assistance by AltSoftLab in 2015-2016
//  The solution source code based on and requires AltSDK (visit http://www.AltSoftLab.com/ for more info),
//  and is provided "as is" without express or implied warranty of any kind.
//
//  The solution can still require several optimizations: some OpenGL display lists has been removed and
//  render logic changed to be more transparent and be possible to port to other render engines (maybe
//  MonoGame or Unity). Also vector arrays can be used for positions, texture coords & colors. Audio is
//  not implemented directly, but all sound calls directed to Audio class. Game menu ported partly.
//
//  Thanks so much to AltSoftLab for help!
//
//  AltSoftLab on Facebook      - http://www.facebook.com/AltSoftLab
//  AltSoftLab on Twitter       - http://www.twitter.com/AltSoftLab
//  AltSoftLab on Instagram     - http://www.instagram.com/AltSoftLab
//  AltSoftLab on Unity forums  - http://forum.unity3d.com/threads/335966
//  AltSoftLab website          - http://www.AltSoftLab.com


using System;

using Alt.Collections.Generic;
using Alt.Sketch;


namespace Neverball.NET
{
    /*
     * sol_step generates a few commands that supersede previous commands
     * of the same type generated by the same sol_step invocation.  The
     * code below provides the means to accumulate commands for later
     * addition to the command queue, while making sure that commands that
     * have been superseded during the accumulation are discarded.
     */


    abstract class enq_fn
    {
        public static enq_fn cmd_enq_fn = null;

        public abstract void func(Command command);
    }


    class solid_phys
    {
        public const double LARGE = 1.0e+5f;

        public static int defer_cmds;

        public static Command cmd = new Command();

        public static CLRList deferred_cmds;


        public static void sol_cmd_enq_func(enq_fn func)
        {
            enq_fn.cmd_enq_fn = func;//enq_fn;
        }


        public static void sol_cmd_enq_deferred()
        {
            CLRList l;
            CLRList r;

            /* Reverse the list to preserve original command order. */

            for (r = null, l = deferred_cmds;
                 l != null;
                 r = CLRList.list_cons(l.data, r), l = CLRList.list_rest(l)) ;

            /* Enqueue commands. */

            for (; r != null; r = CLRList.list_rest(r))
            {
                if (enq_fn.cmd_enq_fn != null)
                    enq_fn.cmd_enq_fn.func((Command)r.data);

                r.data = null;
            }

            deferred_cmds = null;
        }


        public static void sol_cmd_enq(Command lnew)
        {
            if (defer_cmds != 0)
            {
                Command copy;
                CLRList l;
                CLRList p;

                for (p = null, l = deferred_cmds; l != null; p = l, l = l.next)
                {
                    Command cur = (Command)l.data;

                    /* Remove element made obsolete by the lnew command. */

                    if (lnew.type == cur.type &&
                        ((lnew.type == cmd_type.CMD_BODY_TIME &&
                          lnew.bodytime.bi == cur.bodytime.bi) ||
                         (lnew.type == cmd_type.CMD_BODY_PATH &&
                          lnew.bodypath.bi == cur.bodypath.bi)))
                    {
                        //free(cur);
                        cur = null;

                        if (p != null)
                        {
                            p.next = CLRList.list_rest(l);
                        }
                        else
                        {
                            deferred_cmds = CLRList.list_rest(l);
                        }

                        /*
                         * The operation above made the list pointer useless
                         * for the variable update part of the loop, and it
                         * seems a bit involved to recover from that in a
                         * proper fashion.  Fortunately, this very block
                         * ensures that there's only one element to remove, so
                         * no more iterations are needed.
                         */

                        l = null;
                        break;
                    }
                }

                copy = new Command();
                {
                    copy.CopyFrom(lnew);
                    deferred_cmds = CLRList.list_cons(copy, deferred_cmds);
                }
            }
            else if (enq_fn.cmd_enq_fn != null)
            {
                enq_fn.cmd_enq_fn.func(lnew);
            }
        }


        public static float erp(float t)
        {
            return 3.0f * t * t - 2.0f * t * t * t;
        }

        public static float derp(float t)
        {
            return 6.0f * t - 6.0f * t * t;
        }



        /*
         * Compute the states of all switches after DT seconds have passed.
         */
        public static void sol_swch_step(s_file fp, float dt)
        {
            int xi;

            for (xi = 0; xi < fp.m_xc; xi++)
            {
                s_swch xp = fp.m_xv[xi];

                //volatile
                float t = xp.m_t;

                if (t < xp.m_t0)
                {
                    xp.m_t = (t += dt);

                    if (t >= xp.m_t0)
                    {
                        int pi = xp.m_pi;
                        int pj = xp.m_pi;

                        do  /* Tortoise and hare cycle traverser. */
                        {
                            fp.m_pv[pi].m_f = xp.m_f0;
                            fp.m_pv[pj].m_f = xp.m_f0;

                            cmd.type = cmd_type.CMD_PATH_FLAG;
                            cmd.pathflag.pi = pi;
                            cmd.pathflag.f = fp.m_pv[pi].m_f;
                            sol_cmd_enq(cmd);

                            pi = fp.m_pv[pi].m_pi;
                            pj = fp.m_pv[pj].m_pi;
                            pj = fp.m_pv[pj].m_pi;
                        }
                        while (pi != pj);

                        xp.m_f = xp.m_f0;

                        cmd.type = cmd_type.CMD_SWCH_TOGGLE;
                        cmd.swchtoggle.xi = xi;
                        sol_cmd_enq(cmd);
                    }
                }
            }
        }


        /*
         * Compute the positions of all bodies after DT seconds have passed.
         */
        public static void sol_body_step(s_file fp, float dt)
        {
            int i;

            for (i = 0; i < fp.m_bc; i++)
            {
                s_body bp = fp.m_bv[i];// + i;

                if (bp.m_pi >= 0)
                {
                    s_path pp = fp.m_pv[bp.m_pi];

                    if (pp.m_f != 0)
                    {
                        //volatile
                        float t = bp.m_t;

                        bp.m_t = (t += dt);

                        if (t >= pp.m_t)
                        {
                            bp.m_t = 0;
                            bp.m_pi = pp.m_pi;

                            cmd.type = cmd_type.CMD_BODY_TIME;
                            cmd.bodytime.bi = i;
                            cmd.bodytime.t = bp.m_t;
                            sol_cmd_enq(cmd);

                            cmd.type = cmd_type.CMD_BODY_PATH;
                            cmd.bodypath.bi = i;
                            cmd.bodypath.pi = bp.m_pi;
                            sol_cmd_enq(cmd);
                        }
                    }
                }
            }
        }


        /*
         * Test and process the event the ball UI enters a switch. Return 1 if
         * a visible  switch is  activated, return 0  otherwise (no  switch is
         * activated or only invisible switches).
         */
        public static int sol_swch_test(s_file fp, int ui)
        {
            float[] ball_p = fp.m_uv[ui].m_p;
            float ball_r = fp.m_uv[ui].m_r;
            int xi;
            int res = 0;

            for (xi = 0; xi < fp.m_xc; xi++)
            {
                s_swch xp = fp.m_xv[xi];

                /* FIXME enter/exit events don't work for timed switches */

                if (xp.m_t0 == 0 || xp.m_f == xp.m_f0)
                {
                    float l;
                    float[] r = new float[3];

                    r[0] = ball_p[0] - xp.m_p[0];
                    r[1] = ball_p[2] - xp.m_p[2];
                    r[2] = 0;

                    l = Vec3.v_len(r) - xp.m_r;

                    if (l < ball_r &&
                        ball_p[1] > xp.m_p[1] &&
                        ball_p[1] < xp.m_p[1] + Config.SWCH_HEIGHT / 2)
                    {
                        if (xp.m_e == 0 &&
                            l < -ball_r)
                        {
                            int pi = xp.m_pi;
                            int pj = xp.m_pi;

                            /* The ball enters. */

                            if (xp.m_t0 == 0)
                            {
                                xp.m_e = 1;

                                cmd.type = cmd_type.CMD_SWCH_ENTER;
                                cmd.swchenter.xi = xi;
                                sol_cmd_enq(cmd);
                            }

                            /* Toggle the state, update the path. */

                            xp.m_f = xp.m_f != 0 ? 0 : 1;

                            cmd.type = cmd_type.CMD_SWCH_TOGGLE;
                            cmd.swchtoggle.xi = xi;
                            sol_cmd_enq(cmd);

                            do  /* Tortoise and hare cycle traverser. */
                            {
                                fp.m_pv[pi].m_f = xp.m_f;
                                fp.m_pv[pj].m_f = xp.m_f;

                                cmd.type = cmd_type.CMD_PATH_FLAG;
                                cmd.pathflag.pi = pi;
                                cmd.pathflag.f = fp.m_pv[pi].m_f;
                                sol_cmd_enq(cmd);

                                pi = fp.m_pv[pi].m_pi;
                                pj = fp.m_pv[pj].m_pi;
                                pj = fp.m_pv[pj].m_pi;
                            }
                            while (pi != pj);

                            /* It toggled to non-default state, start the timer. */

                            if (xp.m_f != xp.m_f0)
                                xp.m_t = 0.0f;

                            /* If visible, set the result. */

                            if (xp.m_i == 0)
                                res = 1;
                        }
                    }

                    /* The ball exits. */

                    else if (xp.m_e != 0)
                    {
                        xp.m_e = 0;

                        cmd.type = cmd_type.CMD_SWCH_EXIT;
                        cmd.swchexit.xi = xi;
                        sol_cmd_enq(cmd);
                    }
                }
            }
            return res;
        }


        public static void sol_body_p(float[] p,
                        s_file fp,
                        s_body bp)
        {
            float[] v = new float[3];

            if (bp.m_pi >= 0)
            {
                s_path pp = fp.m_pv[bp.m_pi];
                s_path pq = fp.m_pv[pp.m_pi];

                if (pp.m_s != 0)
                {
                    Vec3.v_sub(v, pq.m_p, pp.m_p);
                    Vec3.v_mad(p, pp.m_p, v, erp(bp.m_t / pp.m_t));
                }
                else
                {
                    Vec3.v_sub(v, pq.m_p, pp.m_p);
                    Vec3.v_mad(p, pp.m_p, v, bp.m_t / pp.m_t);
                }
            }
            else
            {
                p[0] = 0.0f;
                p[1] = 0.0f;
                p[2] = 0.0f;
            }
        }


        public static void sol_body_v(float[] v,
                               s_file fp,
                               s_body bp)
        {
            if (bp.m_pi >= 0 &&
                fp.m_pv[bp.m_pi].m_f != 0)
            {
                s_path pp = fp.m_pv[bp.m_pi];
                s_path pq = fp.m_pv[pp.m_pi];

                Vec3.v_sub(v, pq.m_p, pp.m_p);
                Vec3.v_scl(v, v, 1.0f / pp.m_t);

                if (pp.m_s != 0)
                    Vec3.v_scl(v, v, derp(bp.m_t / pp.m_t));
            }
            else
            {
                v[0] = 0.0f;
                v[1] = 0.0f;
                v[2] = 0.0f;
            }
        }


        public static float v_sol(float[] p,
            float[] v,//[3],
            float r)
        {
            float a = Vec3.v_dot(v, v);
            float b = Vec3.v_dot(v, p) * 2.0f;
            float c = Vec3.v_dot(p, p) - r * r;
            float d = b * b - 4.0f * a * c;

            /* HACK: This seems to cause failures to detect low-velocity collision
                     Yet, the potential division by zero below seems fine.
                if (System.Math.Abs(a) < SMALL) return LARGE;
            */

            if (d < 0.0f)
                return (float)LARGE;
            else if (d > 0.0f)
            {
                float t0 = (float)(0.5f * (-b - System.Math.Sqrt(d)) / a);
                float t1 = (float)(0.5f * (-b + System.Math.Sqrt(d)) / a);
                float t = (t0 < t1) ? t0 : t1;

                return (float)((t < 0.0f) ? LARGE : t);
            }
            else return -b * 0.5f / a;
        }


        /*
         * Test if the  ball UI is inside a  jump. Return 1 if yes  and fill P
         * with the destination position, return 0 if not, and return 2 if the
         * ball is on the border of a jump.
         */
        public static int sol_jump_test(s_file fp, float[] p, int ui)
        {
            float[] ball_p = fp.m_uv[ui].m_p;
            float ball_r = fp.m_uv[ui].m_r;
            int ji;
            float l;
            int res = 0;

            for (ji = 0; ji < fp.m_jc; ji++)
            {
                float[] r = new float[3];

                r[0] = ball_p[0] - fp.m_jv[ji].m_p[0];
                r[1] = ball_p[2] - fp.m_jv[ji].m_p[2];
                r[2] = 0;

                l = Vec3.v_len(r) - fp.m_jv[ji].m_r;
                if (l < 0 &&
                    ball_p[1] > fp.m_jv[ji].m_p[1] &&
                    ball_p[1] < fp.m_jv[ji].m_p[1] + Config.JUMP_HEIGHT / 2)
                {
                    if (l < -ball_r)
                    {
                        p[0] = fp.m_jv[ji].m_q[0] + (ball_p[0] - fp.m_jv[ji].m_p[0]);
                        p[1] = fp.m_jv[ji].m_q[1] + (ball_p[1] - fp.m_jv[ji].m_p[1]);
                        p[2] = fp.m_jv[ji].m_q[2] + (ball_p[2] - fp.m_jv[ji].m_p[2]);

                        return 1;
                    }
                    else
                        res = 2;
                }
            }

            return res;
        }


        public static int sol_item_test(s_file fp, float[] p, float item_r)
        {
            float[] ball_p = fp.m_uv[0].m_p;
            float ball_r = fp.m_uv[0].m_r;

            int hi;

            for (hi = 0; hi < fp.m_hc; hi++)
            {
                float[] r = new float[3];

                r[0] = ball_p[0] - fp.m_hv[hi].m_p[0];
                r[1] = ball_p[1] - fp.m_hv[hi].m_p[1];
                r[2] = ball_p[2] - fp.m_hv[hi].m_p[2];

                if (fp.m_hv[hi].m_t != Solid.ITEM_NONE && Vec3.v_len(r) < ball_r + item_r)
                {
                    p[0] = fp.m_hv[hi].m_p[0];
                    p[1] = fp.m_hv[hi].m_p[1];
                    p[2] = fp.m_hv[hi].m_p[2];

                    return hi;
                }
            }

            return -1;
        }


        public static s_goal sol_goal_test(s_file fp, float[] p, int ui)
        {
            float[] ball_p = fp.m_uv[ui].m_p;
            float ball_r = fp.m_uv[ui].m_r;
            int zi;

            for (zi = 0; zi < fp.m_zc; zi++)
            {
                float[] r = new float[3];

                r[0] = ball_p[0] - fp.m_zv[zi].m_p[0];
                r[1] = ball_p[2] - fp.m_zv[zi].m_p[2];
                r[2] = 0;

                if (Vec3.v_len(r) < fp.m_zv[zi].m_r - ball_r &&
                    ball_p[1] > fp.m_zv[zi].m_p[1] &&
                    ball_p[1] < fp.m_zv[zi].m_p[1] + Config.GOAL_HEIGHT / 2)
                {
                    p[0] = fp.m_zv[zi].m_p[0];
                    p[1] = fp.m_zv[zi].m_p[1];
                    p[2] = fp.m_zv[zi].m_p[2];

                    return fp.m_zv[zi];
                }
            }

            return null;
        }


        /*
         * Compute the  earliest time  and position of  the intersection  of a
         * sphere and a vertex.
         *
         * The sphere has radius R and moves along vector V from point P.  The
         * vertex moves  along vector  W from point  Q in a  coordinate system
         * based at O.
         */
        public static float v_vert(float[] Q,
                    float[] o,
                    float[] q,
                    float[] w,
                    float[] p,
                    float[] v,
                    float r)
        {
            float[] O = new float[3];
            float[] P = new float[3];
            float[] V = new float[3];
            float t = (float)LARGE;

            Vec3.v_add(O, o, q);
            Vec3.v_sub(P, p, O);
            Vec3.v_sub(V, v, w);

            if (Vec3.v_dot(P, V) < 0.0f)
            {
                t = v_sol(P, V, r);

                if (t < LARGE)
                    Vec3.v_mad(Q, O, w, t);
            }
            return t;
        }


        /*
         * Compute the  earliest time  and position of  the intersection  of a
         * sphere and an edge.
         *
         * The sphere has radius R and moves along vector V from point P.  The
         * edge moves along vector W from point Q in a coordinate system based
         * at O.  The edge extends along the length of vector U.
         */
        public static float v_edge(float[] Q,
                    float[] o,
                    float[] q,
                    float[] u,
                    float[] w,
                    float[] p,
                    float[] v,
                    float r)
        {
            float[] d = new float[3];
            float[] e = new float[3];
            float[] P = new float[3];
            float[] V = new float[3];
            float du, eu, uu, s, t;

            Vec3.v_sub(d, p, o);
            Vec3.v_sub(d, d, q);
            Vec3.v_sub(e, v, w);

            du = Vec3.v_dot(d, u);
            eu = Vec3.v_dot(e, u);
            uu = Vec3.v_dot(u, u);

            Vec3.v_mad(P, d, u, -du / uu);
            Vec3.v_mad(V, e, u, -eu / uu);

            t = v_sol(P, V, r);
            s = (du + eu * t) / uu;

            if (0.0f <= t && t < LARGE && 0.0f < s && s < 1.0f)
            {
                Vec3.v_mad(d, o, w, t);
                Vec3.v_mad(e, q, u, s);
                Vec3.v_add(Q, e, d);
            }
            else
                t = (float)LARGE;

            return t;
        }


        /*
         * Compute  the earliest  time and  position of  the intersection  of a
         * sphere and a plane.
         *
         * The sphere has radius R and moves along vector V from point P.  The
         * plane  moves  along  vector  W.   The  plane has  normal  N  and  is
         * positioned at distance D from the origin O along that normal.
         */
        public static float v_side(float[] Q,
                    float[] o,
                    float[] w,
                    float[] n,
                    float d,
                    float[] p,
                    float[] v,
                    float r)
        {
            float vn = Vec3.v_dot(v, n);
            float wn = Vec3.v_dot(w, n);
            float t = (float)LARGE;

            if (vn - wn <= 0.0f)
            {
                float on = Vec3.v_dot(o, n);
                float pn = Vec3.v_dot(p, n);

                float u = (r + d + on - pn) / (vn - wn);
                float a = (d + on - pn) / (vn - wn);

                if (0.0f <= u)
                {
                    t = u;

                    Vec3.v_mad(Q, p, v, +t);
                    Vec3.v_mad(Q, Q, n, -r);
                }
                else if (0.0f <= a)
                {
                    t = 0;

                    Vec3.v_mad(Q, p, v, +t);
                    Vec3.v_mad(Q, Q, n, -r);
                }
            }
            return t;
        }


        /*
         * Integrate the rotation of the given basis E under angular velocity W
         * through time DT.
         */
        public static void sol_rotate(float[][] e,
                               float[] w,
                               float dt)
        {
            if (Vec3.v_len(w) > 0.0f)
            {
                float[] a = new float[3];
                float[] M = new float[16];
                float[][] f = new float[3][]
            {
                new float[3],
                new float[3],
                new float[3]
            };

                /* Compute the rotation matrix. */

                Vec3.v_nrm(a, w);
                Vec3.m_rot(M, a, Vec3.v_len(w) * dt);

                /* Apply it to the basis. */

                Vec3.m_vxfm(f[0], M, e[0]);
                Vec3.m_vxfm(f[1], M, e[1]);
                Vec3.m_vxfm(f[2], M, e[2]);

                /* Re-orthonormalize the basis. */

                Vec3.v_crs(e[2], f[0], f[1]);
                Vec3.v_crs(e[1], f[2], f[0]);
                Vec3.v_crs(e[0], f[1], f[2]);

                Vec3.v_nrm(e[0], e[0]);
                Vec3.v_nrm(e[1], e[1]);
                Vec3.v_nrm(e[2], e[2]);
            }
        }


        /*
         * Compute the lnew  linear and angular velocities of  a bouncing ball.
         * Q  gives the  position  of the  point  of impact  and  W gives  the
         * velocity of the object being impacted.
         */
        public static float sol_bounce(s_ball up,
                                float[] q,
                                float[] w,
                                float dt)
        {
            float[] n = new float[3];
            float[] r = new float[3];
            float[] d = new float[3];
            float vn, wn;
            float[] p = up.m_p;
            float[] v = up.m_v;

            /* Find the normal of the impact. */

            Vec3.v_sub(r, p, q);
            Vec3.v_sub(d, v, w);
            Vec3.v_nrm(n, r);

            /* Find the lnew angular velocity. */

            Vec3.v_crs(up.m_w, d, r);
            Vec3.v_scl(up.m_w, up.m_w, -1.0f / (up.m_r * up.m_r));

            /* Find the lnew linear velocity. */

            vn = Vec3.v_dot(v, n);
            wn = Vec3.v_dot(w, n);

            Vec3.v_mad(v, v, n, 1.7f * (wn - vn));

            Vec3.v_mad(p, q, n, up.m_r);

            /* Return the "energy" of the impact, to determine the sound amplitude. */

            return System.Math.Abs(Vec3.v_dot(n, d));
        }


        /*
         * Compute the positions of all balls after DT seconds have passed.
         */
        public static void sol_ball_step(s_file fp, float dt)
        {
            int i;

            for (i = 0; i < fp.m_uc; i++)
            {
                s_ball up = fp.m_uv[i];// + i;

                Vec3.v_mad(up.m_p, up.m_p, up.m_v, dt);

                sol_rotate(up.m_e, up.m_w, dt);
            }
        }


        public static float sol_test_vert(float dt,
                                   float[] T,
                                   s_ball up,
                                   s_vert vp,
                                   float[] o,
                                   float[] w)
        {
            return v_vert(T, o, vp.m_p, w, up.m_p, up.m_v, up.m_r);
        }


        public static float sol_test_edge(float dt,
                                   float[] T,
                                   s_ball up,
                                   s_file fp,
                                   s_edge ep,
                                   float[] o,
                                   float[] w)
        {
            float[] q = new float[3];
            float[] u = new float[3];

            Vec3.v_cpy(q, fp.m_vv[ep.m_vi].m_p);
            Vec3.v_sub(u, fp.m_vv[ep.m_vj].m_p,
                  fp.m_vv[ep.m_vi].m_p);

            return v_edge(T, o, q, u, w, up.m_p, up.m_v, up.m_r);
        }


        public static float sol_test_side(float dt,
                                   float[] T,
                                   s_ball up,
                                   s_file fp,
                                   s_lump lp,
                                   s_side sp,
                                   float[] o,
                                   float[] w)
        {
            float t = v_side(T, o, w, sp.m_n, sp.m_d, up.m_p, up.m_v, up.m_r);
            int i;

            if (t < dt)
                for (i = 0; i < lp.m_sc; i++)
                {
                    s_side sq = fp.m_sv[fp.m_iv[lp.m_s0 + i]];

                    if (sp != sq &&
                        Vec3.v_dot(T, sq.m_n) -
                        Vec3.v_dot(o, sq.m_n) -
                        Vec3.v_dot(w, sq.m_n) * t > sq.m_d)
                        return (float)LARGE;
                }
            return t;
        }


        public static int sol_test_fore(float dt,
                                 s_ball up,
                                 s_side sp,
                                 float[] o,
                                 float[] w)
        {
            float[] q = new float[3];

            /* If the ball is not behind the plane, the test passes. */

            Vec3.v_sub(q, up.m_p, o);

            if (Vec3.v_dot(q, sp.m_n) - sp.m_d + up.m_r >= 0)
                return 1;

            /* If it's not behind the plane after DT seconds, the test passes. */

            Vec3.v_mad(q, q, up.m_v, dt);

            if (Vec3.v_dot(q, sp.m_n) - sp.m_d + up.m_r >= 0)
                return 1;

            /* Else, test fails. */

            return 0;
        }


        public static int sol_test_back(float dt,
                                 s_ball up,
                                 s_side sp,
                                 float[] o,
                                 float[] w)
        {
            float[] q = new float[3];

            /* If the ball is not in front of the plane, the test passes. */

            Vec3.v_sub(q, up.m_p, o);

            if (Vec3.v_dot(q, sp.m_n) - sp.m_d - up.m_r <= 0)
                return 1;

            /* If it's not in front of the plane after DT seconds, the test passes. */

            Vec3.v_mad(q, q, up.m_v, dt);

            if (Vec3.v_dot(q, sp.m_n) - sp.m_d - up.m_r <= 0)
                return 1;

            /* Else, test fails. */

            return 0;
        }


        public static float sol_test_lump(float dt,
                                   float[] T,
                                   s_ball up,
                                   s_file fp,
                                   s_lump lp,
                                   float[] o,
                                   float[] w)
        {
            float[] U = new float[3] { 0.0f, 0.0f, 0.0f };

            float u, t = dt;
            int i;

            /* Short circuit a non-solid lump. */

            if ((lp.m_fl & Solid.L_DETAIL) != 0)
                return t;

            /* Test all verts */

            if (up.m_r > 0.0f)
                for (i = 0; i < lp.m_vc; i++)
                {
                    s_vert vp = fp.m_vv[fp.m_iv[lp.m_v0 + i]];

                    if ((u = sol_test_vert(t, U, up, vp, o, w)) < t)
                    {
                        Vec3.v_cpy(T, U);
                        t = u;
                    }
                }

            /* Test all edges */

            if (up.m_r > 0.0f)
                for (i = 0; i < lp.m_ec; i++)
                {
                    s_edge ep = fp.m_ev[fp.m_iv[lp.m_e0 + i]];

                    if ((u = sol_test_edge(t, U, up, fp, ep, o, w)) < t)
                    {
                        Vec3.v_cpy(T, U);
                        t = u;
                    }
                }

            /* Test all sides */

            for (i = 0; i < lp.m_sc; i++)
            {
                s_side sp = fp.m_sv[fp.m_iv[lp.m_s0 + i]];

                if ((u = sol_test_side(t, U, up, fp, lp, sp, o, w)) < t)
                {
                    Vec3.v_cpy(T, U);
                    t = u;
                }
            }
            return t;
        }


        public static float sol_test_node(float dt,
                                   float[] T,
                                   s_ball up,
                                   s_file fp,
                                   s_node np,
                                   float[] o,
                                   float[] w)
        {
            float u, t = dt;
            float[] U = new float[3];
            int i;

            /* Test all lumps */

            for (i = 0; i < np.m_lc; i++)
            {
                s_lump lp = fp.m_lv[np.m_l0 + i];

                if ((u = sol_test_lump(t, U, up, fp, lp, o, w)) < t)
                {
                    Vec3.v_cpy(T, U);
                    t = u;
                }
            }

            /* Test in front of this node */

            if (np.m_ni >= 0 &&
                sol_test_fore(t, up, fp.m_sv[np.m_si], o, w) != 0)
            {
                s_node nq = fp.m_nv[np.m_ni];

                if ((u = sol_test_node(t, U, up, fp, nq, o, w)) < t)
                {
                    Vec3.v_cpy(T, U);
                    t = u;
                }
            }

            /* Test behind this node */

            if (np.m_nj >= 0 &&
                sol_test_back(t, up, fp.m_sv[np.m_si], o, w) != 0)
            {
                s_node nq = fp.m_nv[np.m_nj];

                if ((u = sol_test_node(t, U, up, fp, nq, o, w)) < t)
                {
                    Vec3.v_cpy(T, U);
                    t = u;
                }
            }

            return t;
        }


        public static float sol_test_body(float dt,
                                   float[] T,
                                   float[] V,
                                   s_ball up,
                                   s_file fp,
                                   s_body bp)
        {
            float u, t = dt;
            float[] U = new float[3];
            float[] O = new float[3];
            float[] W = new float[3];

            s_node np = fp.m_nv[bp.m_ni];

            sol_body_p(O, fp, bp);
            sol_body_v(W, fp, bp);

            if ((u = sol_test_node(t, U, up, fp, np, O, W)) < t)
            {
                Vec3.v_cpy(T, U);
                Vec3.v_cpy(V, W);
                t = u;
            }
            return t;
        }


        public static float sol_test_file(float dt,
                                   float[] T,
                                   float[] V,
                                   s_ball up,
                                   s_file fp)
        {
            float u, t = dt;
            float[] U = new float[3];
            float[] W = new float[3];
            int i;

            for (i = 0; i < fp.m_bc; i++)
            {
                s_body bp = fp.m_bv[i];

                if ((u = sol_test_body(t, U, W, up, fp, bp)) < t)
                {
                    Vec3.v_cpy(T, U);
                    Vec3.v_cpy(V, W);
                    t = u;
                }
            }
            return t;
        }


        /*
         * Step the physics forward DT  seconds under the influence of gravity
         * vector G.  If the ball gets pinched between two moving solids, this
         * loop might not terminate.  It  is better to do something physically
         * impossible than  to lock up the game.   So, if we make  more than C
         * iterations, punt it.
         */

        public static float sol_step(s_file fp, float[] g, float dt, int ui, ref int m, bool m_IsNull)
        {
            float d, e, nt, b = 0.0f, tt = dt;
            float[] P = new float[3];
            float[] V = new float[3];
            float[] v = new float[3];
            float[] r = new float[3];
            float[] a = new float[3];
            int c = 16;

            defer_cmds = 1;

            if (ui < fp.m_uc)
            {
                s_ball up = fp.m_uv[ui];

                /* If the ball is in contact with a surface, apply friction. */

                Vec3.v_cpy(a, up.m_v);
                Vec3.v_cpy(v, up.m_v);
                Vec3.v_cpy(up.m_v, g);

                if (!m_IsNull && sol_test_file(tt, P, V, up, fp) < 0.0005f)
                {
                    Vec3.v_cpy(up.m_v, v);
                    Vec3.v_sub(r, P, up.m_p);

                    if ((d = Vec3.v_dot(r, g) / (Vec3.v_len(r) * Vec3.v_len(g))) > 0.999f)
                    {
                        if ((e = (Vec3.v_len(up.m_v) - dt)) > 0.0f)
                        {
                            /* Scale the linear velocity. */

                            Vec3.v_nrm(up.m_v, up.m_v);
                            Vec3.v_scl(up.m_v, up.m_v, e);

                            /* Scale the angular velocity. */

                            Vec3.v_sub(v, V, up.m_v);
                            Vec3.v_crs(up.m_w, v, r);
                            Vec3.v_scl(up.m_w, up.m_w, -1.0f / (up.m_r * up.m_r));
                        }
                        else
                        {
                            /* Friction has brought the ball to a stop. */

                            up.m_v[0] = 0.0f;
                            up.m_v[1] = 0.0f;
                            up.m_v[2] = 0.0f;

                            m++;
                        }
                    }
                    else Vec3.v_mad(up.m_v, v, g, tt);
                }
                else Vec3.v_mad(up.m_v, v, g, tt);

                /* Test for collision. */

                while (c > 0 && tt > 0 && tt > (nt = sol_test_file(tt, P, V, up, fp)))
                {
                    cmd.type = cmd_type.CMD_STEP_SIMULATION;
                    cmd.stepsim.dt = nt;
                    sol_cmd_enq(cmd);

                    sol_body_step(fp, nt);
                    sol_swch_step(fp, nt);
                    sol_ball_step(fp, nt);

                    tt -= nt;

                    if (b < (d = sol_bounce(up, P, V, nt)))
                        b = d;

                    c--;
                }

                cmd.type = cmd_type.CMD_STEP_SIMULATION;
                cmd.stepsim.dt = tt;
                sol_cmd_enq(cmd);

                sol_body_step(fp, tt);
                sol_swch_step(fp, tt);
                sol_ball_step(fp, tt);
            }

            sol_cmd_enq_deferred();
            defer_cmds = 0;

            return b;
        }
    }
}
